
# JWT Hacking

## Introduction

JSON Web Tokens (JWTs) are an essential component of modern application security, facilitating stateless authentication and secure information exchange. They are widely used in APIs, single-sign-on (SSO) systems, and microservices architectures. While the JWT standard is robust, improper implementation and misconfiguration can introduce critical security vulnerabilities. This report provides a comprehensive overview of JWT security, common attack vectors, real-world examples, and effective mitigation strategies.

## What is a JSON Web Token (JWT)?

A JSON Web Token (JWT) is a compact, URL-safe standard (RFC 7519) for representing claims to be transferred between two parties. The claims are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or encrypted.

A signed JWT consists of three parts separated by dots (`.`):

* **Header**: A Base64Url encoded JSON object that includes metadata about the token, such as the signing algorithm (`alg`) and token type (`typ`).
* **Payload**: A Base64Url encoded JSON object containing the "claims"â€”statements about an entity (typically, the user) and additional data. Claims include registered claims like `iss` (issuer), `sub` (subject), and `exp` (expiration time).
* **Signature**: A cryptographic signature generated by signing the encoded header and payload with a secret or a private key. This is used to verify the token's authenticity and integrity.

The structure is: `Header.Payload.Signature`

## How can JWTs be Hacked?

The security of JWTs hinges on the integrity of the signature and the correct handling of claims by the server. Common implementation flaws include:

* **Signature Stripping (`alg: "none"` Attack)**: An attacker can modify the header to specify the `"none"` algorithm. If the server's JWT library is poorly configured and blindly trusts the `alg` header, it may skip signature verification entirely, allowing the attacker to forge any payload.
* **Algorithm Confusion (Asymmetric to Symmetric Downgrade)**: This occurs when a server expects a token signed with an asymmetric algorithm like `RS256` (using a public/private key pair) but is tricked into verifying it with a symmetric algorithm like `HS256`. An attacker can change the `alg` header to `HS256` and sign the token using the publicly available RSA public key as the secret. The server, now expecting an `HS256` token, will use the same public key to validate the signature, and it will succeed.
* **Weak Secret Keys**: For symmetric algorithms like `HS256`, the security of the entire token relies on the secrecy and strength of the shared secret key. Using weak, guessable, or dictionary-based secrets allows an attacker to brute-force the key offline and then forge any token they wish.
* **Token Replay**: Since JWTs are stateless, a stolen token remains valid until its expiration. If an attacker intercepts a valid token, they can "replay" it to gain unauthorized access to the user's account, especially if a proper revocation mechanism is not in place.
* **Improper Expiration Validation**: Tokens with no `exp` (expiration) claim or with excessively long expiration times pose a significant risk. If compromised, these tokens grant attackers prolonged access.
* **Key ID (`kid`) Header Manipulation**: The `kid` header parameter is used to specify which key should be used to verify a token. In poorly implemented systems, an attacker can manipulate this parameter to force the server to use a weaker key or even read an arbitrary file from the server's filesystem (path traversal).

### Attack Methodology

1.  **Token Discovery and Analysis**: Capture a valid JWT from HTTP headers (e.g., `Authorization: Bearer ...`), cookies, or web storage. Use a tool like [jwt.io](https://jwt.io/) to decode the header and payload and understand its structure and claims.
2.  **Vulnerability Probing**:
    * Test the `"alg": "none"` attack by modifying the header, removing the signature part, and submitting the token.
    * If the original algorithm is `RS256`, attempt the algorithm confusion attack by forging a new token signed with `HS256` using the public key.
3.  **Brute-Forcing the Secret**: If a symmetric algorithm (e.g., `HS256`) is used, use tools like Hashcat or `jwt_tool` with a wordlist to crack the secret key.
4.  **Payload Tampering and Re-signing**: If the secret key is compromised or a vulnerability is found, modify payload claims (e.g., change `{"role": "user"}` to `{"role": "admin"}`) and then re-sign the token to create a valid, privileged token.
5.  **Claim Manipulation**: Abuse time-based claims like `exp` or `nbf` (not before) to extend a token's validity or use it prematurely.

### Real-World Examples

* **Library Vulnerabilities (2015)**: Multiple popular JWT libraries across various programming languages were found to be vulnerable to the `alg: "none"` attack, leading to widespread patches and security advisories.
* **Algorithm Confusion Exploits**: Numerous penetration tests have demonstrated how algorithm confusion can lead to complete account takeover in applications that use RSA-signed JWTs but fail to properly whitelist the accepted signing algorithms.
* **Weak Secret in CTF Challenges & Bug Bounties**: Many real-world bug bounty reports have highlighted applications using weak secrets like `"secret"`, `"password"`, or `"12345678"`, which were quickly brute-forced by security researchers.

## Mitigations

To secure applications using JWTs, developers should adhere to the following best practices:

* **Always Verify the Signature**: This is the most critical step. Never trust the payload of a JWT until its signature has been cryptographically verified.
* **Enforce a Strong Algorithm Whitelist**: On the server side, explicitly specify a list of accepted algorithms (e.g., only `ES256`). Reject any token whose `alg` header does not match an algorithm on this list. Never accept the `"none"` algorithm.
* **Use Strong Secrets and Keys**: For symmetric algorithms (`HS256`/`HS512`), use a long, high-entropy secret that is securely stored. For asymmetric algorithms (`RS256`/`ES256`), ensure the private key is kept confidential.
* **Implement Short Token Expiration**: Keep the validity period (`exp` claim) of tokens as short as is practical (e.g., 5-15 minutes) and implement a refresh token flow for managing longer sessions.
* **Implement a Token Revocation Strategy**: For sensitive actions like logout or password changes, maintain a server-side denylist (blacklist) of revoked tokens to prevent them from being replayed.
* **Do Not Store Sensitive Data in the Payload**: The JWT payload is only Base64Url encoded, not encrypted. It can be easily read by anyone. Avoid storing personally identifiable information (PII) or other secrets directly in the token.
* **Keep JWT Libraries Updated**: Regularly audit and update your third-party JWT libraries to ensure you are protected from newly discovered vulnerabilities.

## Conclusion

JWTs are a powerful and flexible standard for stateless authentication, but they are not a "set-and-forget" solution. Their security is entirely dependent on careful implementation and a deep understanding of potential attack vectors. By enforcing strict validation, using strong cryptographic keys, and following established best practices, developers can leverage the benefits of JWTs while effectively protecting their applications and users from compromise.

## References

* [jwt.io Introduction](https://jwt.io/introduction)
* [PortSwigger Web Security Academy: JWT](https://portswigger.net/web-security/jwt)
* [OWASP JWT Cheat Sheet for Java](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_Cheat_Sheet_for_Java.html)
* [Auth0 Blog: Critical Vulnerabilities in JWT Libraries](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/)
